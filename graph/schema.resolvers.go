package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"log"
	"sdmht-server/game"
	"time"
)

// Time is the resolver for the time field.
func (r *queryResolver) Time(ctx context.Context) (*time.Time, error) {
	now := time.Now()
	return &now, nil
}

// MatchOpponent is the resolver for the matchOpponent field.
func (r *subscriptionResolver) MatchOpponent(ctx context.Context, uid string, size int32, version string) (<-chan any, error) {
	log.Print(uid, " 匹配")
	ch := make(chan any, 10)
	r.game.Pmu.Lock()
	r.game.Player[uid] = game.Player{
		Size:    size,
		Version: version,
	}
	go func() {
		for event := range r.game.Event.On("send_data" + uid) {
			ch <- event.Args[0]
		}
	}()
	go func() {
		is_matched := false
		defer func() {
			r.game.Pmu.Lock()
			delete(r.game.MatchingPlayer, uid)
			delete(r.game.Player, uid)
			r.game.Pmu.Unlock()
			close(ch)
		}()
		for o_uid, p := range r.game.MatchingPlayer {
			if p.Size == size && p.Version == version && o_uid != uid {
				log.Print(uid, " 匹配到 ", o_uid)
				delete(r.game.MatchingPlayer, o_uid)
				r.game.Event.Emit("send_data"+o_uid, uid)
				ch <- ""
				ch <- o_uid
				is_matched = true
				break
			}
		}
		if !is_matched {
			log.Print(uid, " 匹配等待中")
			r.game.MatchingPlayer[uid] = r.game.Player[uid]
		}
		r.game.Pmu.Unlock()
		<-ctx.Done()
		log.Print(uid, " 匹配结束")
	}()
	return ch, nil
}

// SendData is the resolver for the sendData field.
func (r *subscriptionResolver) SendData(ctx context.Context, to string, data any) (<-chan *Void, error) {
	log.Print("向 ", to, " 发送数据：", data)
	ch := make(chan *Void)
	defer close(ch)
	r.game.Event.Emit("send_data"+to, data)
	return ch, nil
}

// Heartbeat is the resolver for the heartbeat field.
func (r *subscriptionResolver) Heartbeat(ctx context.Context, uid string) (<-chan *Void, error) {
	ch := make(chan *Void)
	r.game.Join(uid)
	go func() {
		defer r.game.Leave(uid)
		defer close(ch)
		<-ctx.Done()
	}()
	return ch, nil
}

// ListenAlive is the resolver for the listenAlive field.
func (r *subscriptionResolver) ListenAlive(ctx context.Context, uid string) (<-chan *Void, error) {
	ch := make(chan *Void)
	leave_ch := make(chan any)
	go func() {
		if !r.game.IsOnline(uid) {
			leave_ch <- nil
			return
		}
		for range r.game.Event.On("leave" + uid) {
			leave_ch <- nil
		}
	}()
	go func() {
		defer close(leave_ch)
		defer close(ch)
		for {
			select {
			case <-leave_ch:
				ch <- nil
				return
			case <-ctx.Done():
				return
			}
		}
	}()
	return ch, nil
}

// OnlineCount is the resolver for the onlineCount field.
func (r *subscriptionResolver) OnlineCount(ctx context.Context) (<-chan int32, error) {
	ch := make(chan int32, 1)
	ch <- r.game.OnlineCount()
	go func() {
		defer close(ch)
		for event := range r.game.Event.On("online_changed") {
			ch <- event.Args[0].(int32)
		}
	}()
	return ch, nil
}

// Time is the resolver for the time field.
func (r *subscriptionResolver) Time(ctx context.Context) (<-chan *time.Time, error) {
	ch := make(chan *time.Time)
	ticker := time.NewTicker(1 * time.Second)
	go func() {
		defer close(ch)
		defer ticker.Stop()
		now := time.Now()
		ch <- &now
		for {
			select {
			case <-ticker.C:
				now = time.Now()
				ch <- &now
			case <-ctx.Done():
				return
			}
		}
	}()
	return ch, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
